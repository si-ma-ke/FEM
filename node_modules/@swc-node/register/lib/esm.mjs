"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.load = exports.resolve = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const url_1 = require("url");
const typescript_1 = __importDefault(require("typescript"));
// @ts-expect-error
const read_default_tsconfig_js_1 = require("../lib/read-default-tsconfig.js");
// @ts-expect-error
const register_js_1 = require("../lib/register.js");
const DEFAULT_EXTENSIONS = ['.ts', '.tsx', '.mts', '.cts'];
const TRANSFORM_MAP = new Map();
async function checkRequestURL(parentURL, requestURL) {
    const { dir, name, ext } = (0, path_1.parse)(requestURL);
    const parentDir = (0, path_1.join)(parentURL.startsWith('file://') ? (0, url_1.fileURLToPath)(parentURL) : parentURL, '..');
    if (ext && ext !== '.js' && ext !== '.mjs') {
        try {
            const url = (0, path_1.join)(parentDir, requestURL);
            await fs_1.promises.access(url, fs_1.constants.R_OK);
            return url;
        }
        catch (e) {
            // ignore
        }
    }
    else {
        for (const ext of DEFAULT_EXTENSIONS) {
            try {
                const url = (0, path_1.join)(parentDir, dir, `${name}${ext}`);
                await fs_1.promises.access(url, fs_1.constants.R_OK);
                return url;
            }
            catch (e) {
                // ignore
            }
            try {
                const url = (0, path_1.join)(parentDir, requestURL, `index${ext}`);
                await fs_1.promises.access(url, fs_1.constants.R_OK);
                return url;
            }
            catch (e) {
                // ignore
            }
        }
    }
}
const resolve = async (specifier, context, nextResolve) => {
    const rawUrl = TRANSFORM_MAP.get(specifier);
    if (rawUrl) {
        return { url: new URL(rawUrl).href, format: 'module', shortCircuit: true };
    }
    const { parentURL } = context !== null && context !== void 0 ? context : {};
    if (parentURL && TRANSFORM_MAP.has(parentURL) && specifier.startsWith('.')) {
        const existedURL = await checkRequestURL(parentURL, specifier);
        if (existedURL) {
            const { href: url } = (0, url_1.pathToFileURL)(existedURL);
            TRANSFORM_MAP.set(url, existedURL);
            return {
                url: new URL(url).href,
                shortCircuit: true,
                format: 'module',
            };
        }
    }
    if (DEFAULT_EXTENSIONS.some((ext) => specifier.endsWith(ext))) {
        specifier = specifier.startsWith('file://') ? specifier : (0, url_1.pathToFileURL)(specifier).toString();
        const newUrl = `${specifier}.mjs`;
        TRANSFORM_MAP.set(newUrl, (0, url_1.fileURLToPath)(specifier));
        return {
            shortCircuit: true,
            url: new URL(newUrl).href,
            format: 'module',
        };
    }
    if (parentURL && (0, path_1.isAbsolute)(parentURL)) {
        return nextResolve(specifier, {
            ...context,
            parentURL: (0, url_1.pathToFileURL)(parentURL).toString(),
        });
    }
    return nextResolve(specifier);
};
exports.resolve = resolve;
const load = async (url, context, defaultLoad) => {
    const filePath = TRANSFORM_MAP.get(url);
    if (filePath) {
        const tsconfig = (0, read_default_tsconfig_js_1.readDefaultTsConfig)();
        tsconfig.module = typescript_1.default.ModuleKind.ESNext;
        const code = await (0, register_js_1.compile)(await fs_1.promises.readFile(filePath, 'utf8'), filePath, tsconfig, true);
        return {
            format: context.format,
            source: code,
            shortCircuit: true,
        };
    }
    return defaultLoad(url, context, defaultLoad);
};
exports.load = load;
//# sourceMappingURL=esm.mjs.map